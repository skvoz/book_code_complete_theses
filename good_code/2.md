#Классы
## **[Контрольные вопросы](../control_list/classes.md)**
##**Ключевые моменты**
- Интерфейс класса должен формировать согласованную абстракцию. Многие
проблемы объясняются нарушением одного этого принципа.
- Интерфейс класса должен что то скрывать — особенности взаимодействия с
системой, аспекты проектирования или детали реализации.
- Включение обычно предпочтительнее, чем наследование, если только вы не
моделируете отношение «является».
- Наследование — полезный инструмент, но оно повышает сложность, что про
тиворечит Главному Техническому Императиву Разработки ПО, которым явля
ется управление сложностью.
- Классы — главное средство управления сложностью. Уделите их проектирова
нию столько времени, сколько нужно для достижения этой цели.

##Основы классов: абстрактные типы данных
Абстрактный тип данных (АТД) — это набор, включающий данные и выполняемые над ними операции. Пример   : файл,
со всеми выполняемыми над ним операциями (CRUD).Не имея ясного представления об АТД, программисты создают классы,
которые только называются «классами», будучи на самом деле лишь удобными контейнерами, содержащими наборы плохо
согласующихся друг с другом данных и методов. Фактически классы это АТД поддерживающие наследование и полиморфизм.

##Качественные интерфейсы классов
Первый и, наверное, самый важный этап разработки высококачественного класса — создание адекватного интерфейса.
Это подразумевает, что интерфейс должен представлять хорошую абстракцию, скрывающую детали реализации класса. 
Некоторые советы для форимирования хорошего интерфейса класса:
- **класс реализация одной абстракции**
- **предоставляйте методы с противоположными им методами**
- **делайте интерфейсы класса програмными а не семантическими**
 семантический интерфейс , это такая реализация логики которую нельзя проверить компилятором. Напирмер , класс А может
 вызываться только после класса Б
- **опасайтесь нарушения целостности интерфейса при изменении класса** - не включайте в класс открытые члены плохо 
 согласующиеся с абстракцией интерфейса.
- **минимизируйте доступность классов и их членов**
если вы не знаете сделать метод открытым или закрытым , выбирайте самый высокий уровень защищенности. Еще один хороший
вариант задать себе вопрос : какой уровень защищенности лучше всего сохраняет абстракцию интерфейса.
- **не делайте данные-члены открытыми**
- **цените легкость чтения выше чем удобство написания**

Если вам требуется смотреть на реализацию класса чтб понять как его использовать , вы программируете не в соответсвтии
с интерфейсом , а сквозь интерфейс в соответствии с реализацией. Программирование сквозь интерфейс разрушает 
инскапсуляцию, а затем и абстракцию.

##Вопросы проектирования и реализации
-**Настороженно относитесь к классам, содержащим более семи элементов
данных членов** При выполнении других заданий человек может удерживать в
памяти 7±2 дискретных элементов (Miller, 1956). Если класс содержит более семи
элементов данных членов, подумайте, не разделить ли его на несколько менее
крупных классов (Riel, 1996). Можете ориентироваться на верхнюю границу диа
пазона «7±2», если данные члены являются примитивными типами, такими как
целые числа и строки, и на нижнюю, если они являются сложными объектами.

-**Проектируйте и документируйте классы с учетом возможности насле
дования или запретите его**

-**Соблюдайте принцип подстановки Лисков (Liskov Substitution Principle, LSP)**
Клиенты должны иметь возможность использования подклассов через ин
терфейс базового класса, не замечая никаких различий» (Hunt and Thomas, 2000).
Иначе говоря, все методы базового класса должны иметь в каждом производном
классе то же значение.
Перемещайте общие интерфейсы, данные и формы поведения на как мож
но более высокий уровень иерархии наследования Чем ближе интерфейсы,
данные и формы поведения к корню дерева наследования, тем легче производ
ным классам их использовать.

-**С подозрением относитесь к классам, объекты которых создаются в един
ственном экземпляре** Использование единственного экземпляра класса может
указывать на то, что вы спутали объекты с классами. Подумайте, можно ли про
сто создать объект вместо нового класса. Можно ли конкретный производный класс
представить только данными, а не отдельным классом? Шаблон Одиночка (Sing
leton) — примечательное исключение из этого правила.


-**С подозрением относитесь к базовым классам, имеющим только один про
изводный класс **

-**Избегайте многоуровневых иерархий наследования**
Артур Риэль в прекрасной книге «Object Oriented Design Heuristics» (Riel, 1996)
предлагает ограничивать иерархии наследования максимум шестью уровнями. Он
основывает свой совет на «магическом числе 7±2», но мне кажется, что это слиш
ком оптимистично. Опыт подсказывает мне, что большинству людей трудно удер
жать в уме более двух или трех уровней наследования сразу. «Магическое число
7±2» скорее характеризует максимально допустимое общее количество подклас
сов базового класса, а не уровней иерархии наследования.

-**Предпочитайте полиморфизм, а не крупномасштабную проверку типов**

-**Правила наследования **
    - если несколько классов имеют общие данные, но не фор
      мы поведения, создайте общий объект, который можно было
      бы включить во все эти классы;
    - если несколько классов имеют общие формы поведения,
      но не данные, сделайте эти классы производными от общего
      базового класса, определяющего общие методы;
    - если несколько классов имеют общие данные и формы поведения, сделайте эти
      классы производными от общего базового класса, определяющего общие дан
      ные и методы;
    - используйте наследование, если хотите, чтобы интерфейс определялся базо
      вым классом, и включение, если хотите сами контролировать интерфейс.
-Включайте в класс как можно меньше методов

-Избегайте опосредованных вызовов методов других классов Непосред
ственные связи довольно опасны. Опосредованные связи, такие как account.Con
tactPerson() . DaytimeContactInfo() . PhoneNumber(), опасны еще больше. В связи с этим
ученые сформулировали «Правило Деметры (Law of Demeter)» (Lieberherr and
Holland, 1989), которое гласит, что Объект A может вызывать любые из собствен
ных методов. Если он создает Объект B, он может вызывать любые методы Объекта
B, но ему не следует вызывать методы объектов, возвраща
емых Объектом B. В нашем случае это означает, что вызов
account . ContactPerson() приемлем, однако вызова account.
ContactPerson() .DaytimeContactInfo() следовало бы избежать.

##Разумные причины создания классов
- моделирование объектов реального мира;
- моделирование абстрактных объектов;
- снижение сложности;
- изоляция сложности;
- сокрытие деталей реализации;
- ограничение влияния изменений;
- сокрытие глобальных данных;
- упрощение передачи параметров в методы;
- создание центральных точек управления;
- облегчение повторного использования кода;
- планирование создания семейства программ;
- упаковка родственных операцией;
- выполнение специфического вида рефакторинга.
##Магические методы PHP 5.5
- **__construct()** 
- **__destruct()** 
- **__call()** 
- **__callStatic()** 
- **__get()** 
- **__set()** 
- **__isset()** 
- **__unset()** 
- **__sleep()** 
- **__wakeup()** 
- **__toString()** 
- **__invoke()** 
- **__set_state()** 
- **__clone()** 
- **__debugInfo()**

