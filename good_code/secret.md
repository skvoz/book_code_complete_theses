#Сокрытие информации
## Пример
Допустим, вы пишете программу, каждый объект которой должен иметь уникаль-
ный идентификатор, хранящийся в переменной члене id. Один подход к проек-
тированию может заключаться в применении целочисленных идентификаторов
и хранении максимального на данный момент идентификатора в глобальной
переменной g_maxId. При создании новых объектов вы можете — скажем, в кон-
структоре каждого объекта — просто выполнять команду id = ++g_maxId, что
гарантирует уникальность идентификаторов, и требует абсолютно минимального
кода при создании каждого объекта. Разве это может привести к каким нибудь
неприятностям?

Может. Что, если вы захотите зарезервировать диапазоны идентификаторов для
определенных целей? Что, если для повышения защищенности программы вы за-
хотите назначать идентификаторы в другом порядке? А если вы захотите повтор-
но задействовать идентификаторы уничтоженных объектов? Или включить в про-
грамму диагностический тест, проверяющий, не превысило ли число идентифи-
каторов допустимый предел? Если, назначая идентификаторы, вы распространите
команды id = ++g_maxId по всей программе, вам придется изменить каждую из
них. Кроме того, этот подход небезопасен в многопоточной среде.

Способ генерации новых идентификаторов является тем аспектом проектирования,
который следует скрыть. Применив команду ++g_maxId, вы раскроете сведения о
том, что новый идентификатор создается просто путем увеличения переменной
g_maxId. Если же вместо этого вы используете команды id = NewId(), вы скроете
информацию о способе создания новых идентификаторов. Сам метод NewId()
может состоять из единственной строки return ( ++g_maxId ) или ее эквивален-
та, однако, если вы позднее решите зарезервировать определенные диапазоны
идентификаторов для специфических целей или повторно использовать старые
идентификаторы, вам придется изменить только метод NewId(), но не десятки
команд id = NewId(). Какими бы сложными ни были изменения метода NewId(),
они не повлияют ни на какую другую часть программы.

Допустим теперь, что вам понадобилось изменить тип идентификатора с цело-
численного на строковый. Если по всей программе у вас разбросаны объявления
вроде int id, метод NewId() не поможет. В этом случае вам тоже придется просмо-
треть всю программу и внести десятки или сотни изменений.

Итак, тип идентификатора — это тоже секрет, который следует скрыть. Показывая,
что идентификаторы — целые числа, вы поощряете программистов выполнять над
ними такие операции, как >, < и =. Программируя на C++, вы могли бы не объявлять
идентификаторы как int, а назначить им при помощи директивы typedef пользо-
вательский тип IdType соответствующий тому же int. Или же вы могли бы создать
простой класс IdType. Повторю еще раз: сокрытие аспектов проектирования по-
зволяет значительно уменьшить объем кода, затрагиваемого изменениями.
Сокрытие информации полезно на всех уровнях проектирования: от при
менения именованных констант вместо литералов до создания типов
данных и проектирования классов, методов и подсистем.

## Категории секретов
- скрывающие сложность
- скрывающие источник изменений с целью локализации возможных изменений

## Важность сокрытия информации
Почаще задавайте себе вопрос «Что мне скрыть?», и вы удивитесь, сколь
ко проблем проектирования растает на ваших глазах

